**Indicate if your solution is deadlock- and starvation-free and explain why**

Yes, this solution is deadlock and starvation-free. My solution is deadlock-free because there are never any threads that are permanently left waiting for other threads. By using broadcast within visitors to ensure all guide threads are woken up, we ensure that if a guide can admit the visitor, it will and allow it to proceed. Any time a thread is forced to wait, there always exists a signal or broadcast to wake its resting threads. At no time within our program do two threads wait on each other in a manner that would create a deadlock. Every process that requires waiting will eventually be unblocked by the opposing thread type. When a guide is waiting to enter the museum, they are awoken by the last guide that leaves. When a visitor is waiting to enter, they are awoken after the guide admits them. When a guide is waiting for a visitor to arrive, they are awoken by a visitors arrival.
